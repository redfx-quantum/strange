<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ControlledBlockGate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Strange</a> &gt; <a href="index.source.html" class="el_package">org.redfx.strange</a> &gt; <span class="el_source">ControlledBlockGate.java</span></div><h1>ControlledBlockGate.java</h1><pre class="source lang-java linenums">/*-
 * #%L
 * Strange
 * %%
 * Copyright (C) 2020 Johan Vos
 * %%
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Johan Vos nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */
package org.redfx.strange;

import org.redfx.strange.gate.PermutationGate;
import org.redfx.strange.local.Computations;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 *
 * A Gate describes an operation on one or more qubits.
 *
 * @author johan
 * @param &lt;T&gt; type of the Block
 * @version $Id: $Id
 */
public class ControlledBlockGate&lt;T&gt; extends BlockGate {

    private int control;
    private int size;
<span class="pc" id="L54">    private int high = -1;</span>
<span class="pc" id="L55">    private int haq = -1;</span>
<span class="pc" id="L56">    int low = 0;</span>
<span class="pc" id="L57">    private Complex[][] matrix = null;</span>
    
    /**
     * &lt;p&gt;Constructor for ControlledBlockGate.&lt;/p&gt;
     */
<span class="nc" id="L62">    protected ControlledBlockGate() {</span>
<span class="nc" id="L63">    }</span>
    
    /**
     * Create a controlled blockgate
     *
     * @param bg the block gate
     * @param idx the start-index of the block gate
     * @param control the index of the control qubit
     */
    public ControlledBlockGate(BlockGate bg, int idx, int control) {
<span class="fc" id="L73">        this (bg.getBlock(), idx, control);</span>
<span class="fc" id="L74">    }</span>
    
    /**
     * Create a block
     *
     * @param block a {@link org.redfx.strange.Block} object
     * @param idx a int
     * @param control the control qubit
     */
    public ControlledBlockGate (Block block, int idx, int control) {
<span class="fc" id="L84">        super(block, idx);</span>
<span class="fc" id="L85">        this.control = control;</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (control &gt; idx) {</span>
<span class="fc" id="L87">            this.haq = idx + block.getNQubits();</span>
        } else {
<span class="fc" id="L89">            this.haq = idx+block.getNQubits() -1;</span>
        }
<span class="fc" id="L91">    }</span>

    /** {@inheritDoc} */
    @Override
    public List&lt;Integer&gt; getAffectedQubitIndexes() {
<span class="nc" id="L96">        ArrayList answer = new ArrayList(super.getAffectedQubitIndexes());</span>
<span class="nc" id="L97">        answer.add(control);</span>
<span class="nc" id="L98">        return answer;</span>
    }

    /** {@inheritDoc} */
    @Override
    public int getHighestAffectedQubitIndex() {
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (high &lt; 0) calculateHighLow();</span>
<span class="fc" id="L105">        return this.haq;</span>
    }

    /** {@inheritDoc} */
    @Override
    public String getCaption() {
<span class="nc" id="L111">        return &quot;CB&quot;;</span>
    }

    /** {@inheritDoc} */
    @Override
    public String getName() {
<span class="nc" id="L117">        return &quot;CBlockGate&quot;;</span>
    }

    /** {@inheritDoc} */
    @Override
    public String getGroup() {
<span class="nc" id="L123">        return &quot;CBlockGroup&quot;;</span>
    }
    
    /**
     * &lt;p&gt;getControlQubit.&lt;/p&gt;
     *
     * @return a int
     */
    public int getControlQubit() {
<span class="fc" id="L132">        return this.control;</span>
    }

    /**
     * &lt;p&gt;calculateHighLow.&lt;/p&gt;
     */
    public void calculateHighLow() {
<span class="fc" id="L139">        this.high = control;</span>
<span class="fc" id="L140">        int gap = control - idx;</span>
<span class="fc" id="L141">        int bs = block.getNQubits();</span>
<span class="fc" id="L142">        low = 0;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">         if (control &gt; idx) {</span>
<span class="fc" id="L144">             low =idx;</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">                if (gap &lt; bs) {</span>
<span class="nc" id="L146">                    throw new IllegalArgumentException(&quot;Can't have control at &quot; + control + &quot; for gate with size &quot; + bs + &quot; starting at &quot; + idx);</span>
                }
<span class="fc bfc" id="L148" title="All 2 branches covered.">                if (gap &gt; bs) {</span>
<span class="fc" id="L149">                    high = control;</span>
                }
            } else {
<span class="fc" id="L152">                low = control;</span>
<span class="fc" id="L153">                high = idx + bs - 1;</span>
         }
<span class="fc" id="L155">         size = high - low + 1;</span>
<span class="fc" id="L156">    }</span>
    
    /**
     * &lt;p&gt;Getter for the field &lt;code&gt;low&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a int
     */
    public int getLow() {
<span class="fc" id="L164">        return this.low;</span>
    }
    
    /**
     * &lt;p&gt;correctHigh.&lt;/p&gt;
     *
     * @param h a int
     */
    public void correctHigh(int h) {
<span class="nc" id="L173">        this.high = h;</span>
<span class="nc" id="L174">    }</span>
    
    /** {@inheritDoc} */
    @Override
    public Complex[][] getMatrix() {
<span class="fc" id="L179">        return getMatrix(null);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Complex[][] getMatrix(QuantumExecutionEnvironment qee) {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (matrix == null) {</span>
<span class="fc" id="L186">            int low = 0;</span>
<span class="fc" id="L187">            this.high = control;</span>
<span class="fc" id="L188">            this.size = super.getSize() + 1;</span>
<span class="fc" id="L189">            int gap = control - idx;</span>
<span class="fc" id="L190">            List&lt;PermutationGate&gt; perm = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L191">            int bs = block.getNQubits();</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">            if (control &gt; idx) {</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                if (gap &lt; bs) {</span>
<span class="nc" id="L194">                    throw new IllegalArgumentException(&quot;Can't have control at &quot; + control + &quot; for gate with size &quot; + bs + &quot; starting at &quot; + idx);</span>
                }
<span class="fc" id="L196">                low = idx;</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">                if (gap &gt; bs) {</span>
<span class="fc" id="L198">                    high = control;</span>
<span class="fc" id="L199">                    size = high - low + 1;</span>
<span class="fc" id="L200">                    PermutationGate pg = new PermutationGate(control-low, control-low - gap + bs, size);</span>
<span class="fc" id="L201">                    perm.add(pg);</span>
<span class="fc" id="L202">                }</span>
            } else {
<span class="fc" id="L204">                low = control;</span>
<span class="fc" id="L205">                high = idx + bs - 1;</span>
<span class="fc" id="L206">                size = high - low + 1;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">                for (int i = 0; i &lt; size - 1; i++) {</span>
<span class="fc" id="L208">                    PermutationGate pg = new PermutationGate(i, i + 1, size);</span>
<span class="fc" id="L209">                    perm.add(0,pg);</span>
                }
            }
<span class="fc" id="L212">            Complex[][] part = block.getMatrix(qee);</span>
          
<span class="fc" id="L214">            int dim = part.length;</span>
<span class="fc" id="L215">            matrix = Computations.createIdentity(2 * dim);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">            for (int i = 0; i &lt; dim; i++) {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                for (int j = 0; j &lt; dim; j++) {</span>
<span class="fc" id="L218">                    matrix[i + dim][j + dim] = part[i][j];</span>
                }
            }
<span class="fc" id="L221">        } else {</span>
<span class="nc" id="L222">            System.err.println(&quot;Matrix was cached&quot;);</span>
        }
<span class="fc" id="L224">        return matrix;</span>
    }
    
    /** {@inheritDoc} */
    @Override
    public boolean hasOptimization() {
<span class="fc" id="L230">        return true;</span>
    }

    /** {@inheritDoc} */
    @Override
    public Complex[] applyOptimize(Complex[] v) {
<span class="fc" id="L236">        int size = v.length;</span>
<span class="fc" id="L237">        Complex[] answer = new Complex[size];</span>
<span class="fc" id="L238">        int dim = size / 2;</span>
<span class="fc" id="L239">        Complex[] oldv = new Complex[dim];</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">        for (int i = 0; i &lt; dim; i++) {</span>
<span class="fc" id="L241">            oldv[i] = v[i + dim];</span>
        }
<span class="fc" id="L243">        Complex[] p2 = block.applyOptimize(oldv, inverse);</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (int i = 0; i &lt; dim; i++) {</span>
<span class="fc" id="L245">            answer[i] = v[i];</span>
<span class="fc" id="L246">            answer[dim + i] = p2[i];</span>
        }
<span class="fc" id="L248">        return answer;</span>
    }

    /**
     * &lt;p&gt;Getter for the field &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a int
     */
    public int getSize() {
<span class="fc" id="L257">        return block.getNQubits()+1;</span>
    }
    
    /** {@inheritDoc} */
    @Override public String toString() {
<span class="fc" id="L262">        return &quot;ControlledGate for &quot;+super.toString();</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>